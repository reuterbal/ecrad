! radintg_zrgp_mod.fypp - Wrap the block-allocated radiation fields from RADINTG in a FIELD API stack
!
! (C) Copyright 2022- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

#:mute
#:set radiation_config_file = os.path.dirname(os.path.abspath(_THIS_FILE_)) + '/radiation_fields_config.yaml'
#:set radiation_config = field_config.VariableConfiguration(radiation_config_file)
#:set zrgp_in = radiation_config.groups['ZRGP_IN']
#:set zrgp_out = radiation_config.groups['ZRGP_OUT']
#:set zrgp_local = radiation_config.groups['ZRGP_LOCAL']
#:set variables = zrgp_in.variables + zrgp_out.variables + zrgp_local.variables
#:set variable_names = list(dict.fromkeys(v.name for v in variables))
#:set variable_dim = {v.name: 2 if v.dim[0] == 1 else 3 for v in variables}
#:def kflds_from_dim(dim)
$:'*'.join(str(d) for d in dim)
#:enddef
#:endmute

MODULE RADINTG_ZRGP_MOD

USE PARKIND1     , ONLY : JPRB, JPIM
USE YOMHOOK      , ONLY : LHOOK, DR_HOOK, JPHOOK

#ifdef HAVE_FIELD_API
USE FIELD_MODULE
USE FIELD_BASIC_MODULE
#endif

IMPLICIT NONE

PRIVATE
PUBLIC :: RADINTG_ZRGP_TYPE

INTEGER, PARAMETER :: NUNDEFLD = -99999999

TYPE RADINTG_ZRGP_TYPE
  ! Field counts and offset indices for ZRGP
  INTEGER(KIND=JPIM) :: IFLDSIN, IFLDSOUT, IFLDSTOT
  INTEGER(KIND=JPIM) :: IINBEG, IINEND, IOUTBEG, IOUTEND
  #:for v_name in variable_names
  INTEGER(KIND=JPIM) :: ${v_name}$
  #:endfor

#ifdef HAVE_FIELD_API
  ! Field stack wrapper for ZRGP
  CLASS(FIELD_3RB), POINTER :: FIELD_WRAPPER
  TYPE(FIELD_BASIC_PTR), ALLOCATABLE :: MEMBERS(:)
#endif

CONTAINS
  PROCEDURE :: SETUP => RADINTG_ZRGP_SETUP
#ifdef HAVE_FIELD_API
  PROCEDURE :: SETUP_FIELD => RADINTG_ZRGP_SETUP_FIELD
#endif
  PROCEDURE :: COPY_INPUTS => IFS_COPY_INPUTS_TO_BLOCKED
  PROCEDURE :: COPY_FLUXES => IFS_COPY_FLUXES_FROM_BLOCKED

END TYPE RADINTG_ZRGP_TYPE

CONTAINS

INTEGER(KIND=JPIM) FUNCTION INDRAD(KNEXT,KFLDS,LDUSE)
INTEGER(KIND=JPIM),INTENT(INOUT) :: KNEXT
INTEGER(KIND=JPIM),INTENT(IN) :: KFLDS
LOGICAL,INTENT(IN) :: LDUSE
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('RADINTG:INDRAD',0,ZHOOK_HANDLE)

IF( LDUSE )THEN
  INDRAD=KNEXT
  KNEXT=KNEXT+KFLDS
ELSE
  INDRAD=NUNDEFLD
ENDIF

IF (LHOOK) CALL DR_HOOK('RADINTG:INDRAD',1,ZHOOK_HANDLE)

END FUNCTION INDRAD


SUBROUTINE RADINTG_ZRGP_SETUP( &
  & SELF, NLEV, NLWEMISS, &
  & NLWOUT, NSW, NFSD, NRFTOTAL_RADGRID, &
  & NPROGAER, NRADAER, &
  & LDEBUG, LSPPRAD, LRAYFM, &
  & LAPPROXLWUPDATE, LAPPROXSWUPDATE, &
  & LEPO3RA, LDIAGFORCING)

  USE YOMLUN_ECRAD       , ONLY : NULOUT

  IMPLICIT NONE

  CLASS(RADINTG_ZRGP_TYPE), INTENT(INOUT):: SELF
  INTEGER, INTENT(IN)                    :: NLEV
  INTEGER, INTENT(IN)                    :: NLWEMISS, NLWOUT, NSW
  INTEGER, INTENT(IN)                    :: NFSD, NRFTOTAL_RADGRID
  INTEGER, INTENT(IN)                    :: NPROGAER, NRADAER
  LOGICAL, INTENT(IN)                    :: LDEBUG, LSPPRAD, LRAYFM
  LOGICAL, INTENT(IN)                    :: LAPPROXLWUPDATE, LAPPROXSWUPDATE
  LOGICAL, INTENT(IN)                    :: LEPO3RA, LDIAGFORCING

  INTEGER(KIND=JPIM), ALLOCATABLE     :: MEMBER_MAP(:)
  INTEGER(KIND=JPIM)                  :: INEXT
  REAL(KIND=JPHOOK)                   :: ZHOOK_HANDLE

#ifdef BITIDENTITY_TESTING
  LOGICAL, PARAMETER :: LTEST_BITID = .TRUE.
#else
  LOGICAL, PARAMETER :: LTEST_BITID = .FALSE.
#endif

#include "abor1.intfb.h"

  IF (LHOOK) CALL DR_HOOK('RADINTG_ZRGP_SETUP',0,ZHOOK_HANDLE)

  INEXT = 1
  SELF%IINBEG=1
  #:for v in zrgp_in.variables
  SELF%${v.name}$ = INDRAD( INEXT, ${kflds_from_dim(v.dim)}$, ${v.condition}$)
  #:endfor
  SELF%IINEND = INEXT-1
  SELF%IOUTBEG = INEXT
  #:for v in zrgp_out.variables
  SELF%${v.name}$ = INDRAD( INEXT, ${kflds_from_dim(v.dim)}$, ${v.condition}$)
  #:endfor
  SELF%IOUTEND = INEXT-1
  #:for v in zrgp_local.variables
  SELF%${v.name}$ = INDRAD( INEXT, ${kflds_from_dim(v.dim)}$, ${v.condition}$)
  #:endfor

  IF (LDEBUG) THEN
    #:for v_name in variable_names
    WRITE(NULOUT,'("RADINTG: ",A7,"=",I12)') '${v_name.upper()}$',SELF%${v_name}$
    #:endfor
  ENDIF

  SELF%IFLDSIN = SELF%IINEND - SELF%IINBEG + 1
  SELF%IFLDSOUT = SELF%IOUTEND - SELF%IOUTBEG + 1
  SELF%IFLDSTOT = INEXT - 1

  WRITE(NULOUT,'("RADINTG: IFLDSIN   =",I12)')SELF%IFLDSIN
  WRITE(NULOUT,'("RADINTG: IFLDSOUT  =",I12)')SELF%IFLDSOUT
  WRITE(NULOUT,'("RADINTG: IFLDSTOT  =",I12)')SELF%IFLDSTOT

  IF (LHOOK) CALL DR_HOOK('RADINTG_ZRGP_SETUP',1,ZHOOK_HANDLE)

END SUBROUTINE RADINTG_ZRGP_SETUP

#ifdef HAVE_FIELD_API

SUBROUTINE FIELD_INDRAD(MEMBER_MAP, KIDX, KNEXT, KFLDS, LDUSE)
  INTEGER(KIND=JPIM), INTENT(INOUT) :: MEMBER_MAP(:)
  INTEGER(KIND=JPIM), INTENT(IN) :: KIDX
  INTEGER(KIND=JPIM), INTENT(INOUT) :: KNEXT
  INTEGER(KIND=JPIM), INTENT(IN) :: KFLDS
  LOGICAL, INTENT(IN) :: LDUSE
  INTEGER(KIND=JPIM) :: ISTART, IEND
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

  IF (LHOOK) CALL DR_HOOK('RADINTG:FIELD_INDRAD',0,ZHOOK_HANDLE)

  ISTART = KNEXT
  IF( LDUSE .AND. KFLDS > 0 ) THEN
      IEND = ISTART + KFLDS - 1
      KNEXT = IEND + 1
  ELSE
      IEND = ISTART
  ENDIF
  MEMBER_MAP(2*KIDX-1) = ISTART
  MEMBER_MAP(2*KIDX) = IEND

  IF (LHOOK) CALL DR_HOOK('RADINTG:FIELD_INDRAD',1,ZHOOK_HANDLE)

END SUBROUTINE FIELD_INDRAD

SUBROUTINE RADINTG_ZRGP_SETUP_FIELD( &
  & SELF, ZRGP, NLEV, NLWEMISS, &
  & NLWOUT, NSW, NFSD, NRFTOTAL_RADGRID, &
  & NPROGAER, NRADAER, &
  & LDEBUG, LSPPRAD, LRAYFM, &
  & LAPPROXLWUPDATE, LAPPROXSWUPDATE, &
  & LEPO3RA, LDIAGFORCING)

  USE FIELD_FACTORY_MODULE
  USE YOMLUN_ECRAD, ONLY: NULOUT

  IMPLICIT NONE

  CLASS(RADINTG_ZRGP_TYPE), INTENT(INOUT):: SELF
  REAL(KIND=JPRB), INTENT(INOUT), TARGET :: ZRGP(:,:,:)
  INTEGER, INTENT(IN)                    :: NLEV
  INTEGER, INTENT(IN)                    :: NLWEMISS, NLWOUT, NSW
  INTEGER, INTENT(IN)                    :: NFSD, NRFTOTAL_RADGRID
  INTEGER, INTENT(IN)                    :: NPROGAER, NRADAER
  LOGICAL, INTENT(IN)                    :: LDEBUG, LSPPRAD, LRAYFM
  LOGICAL, INTENT(IN)                    :: LAPPROXLWUPDATE, LAPPROXSWUPDATE
  LOGICAL, INTENT(IN)                    :: LEPO3RA, LDIAGFORCING

  INTEGER(KIND=JPIM), ALLOCATABLE     :: MEMBER_MAP(:)
  INTEGER(KIND=JPIM), ALLOCATABLE     :: MEMBER_RANKS(:)
  INTEGER(KIND=JPIM)                  :: INEXT
  REAL(KIND=JPHOOK)                   :: ZHOOK_HANDLE

#ifdef BITIDENTITY_TESTING
  LOGICAL, PARAMETER :: LTEST_BITID = .TRUE.
#else
  LOGICAL, PARAMETER :: LTEST_BITID = .FALSE.
#endif

#include "abor1.intfb.h"

  IF (LHOOK) CALL DR_HOOK('RADINTG_ZRGP_SETUP_FIELD',0,ZHOOK_HANDLE)

  ALLOCATE(MEMBER_MAP(${len(variables) * 2}$))
  ALLOCATE(MEMBER_RANKS(${len(variables)}$))

  INEXT = 1
  #:for idx, v in enumerate(variables)
  ! ${v.name}$
  CALL FIELD_INDRAD( MEMBER_MAP, ${idx + 1}$, INEXT, ${kflds_from_dim(v.dim)}$, ${v.condition}$)
  MEMBER_RANKS(${idx+1}$) = ${variable_dim[v.name]}$
  #:endfor

  CALL FIELD_NEW(SELF%FIELD_WRAPPER, SELF%MEMBERS, DATA=ZRGP, MEMBER_MAP=MEMBER_MAP, MEMBER_RANKS=MEMBER_RANKS)

  IF (LDEBUG) THEN
    #:for idx, v in enumerate(variables)
    WRITE(NULOUT,'("RADINTG_ZRGP_SETUP_FIELD: ",A7,"=",I8,":",I8)') '${v.name.upper()}$',MEMBER_MAP(${2*idx+1}$),MEMBER_MAP(${2*idx+2}$)
    #:endfor
  ENDIF

  IF (LHOOK) CALL DR_HOOK('RADINTG_ZRGP_SETUP_FIELD_API',1,ZHOOK_HANDLE)

END SUBROUTINE RADINTG_ZRGP_SETUP_FIELD

#endif

subroutine ifs_copy_inputs_to_blocked ( &
  & zrgp_fields, yradiation, ncol, nlev, nproma, &
  & single_level, thermodynamics, gas, cloud, aerosol, &
  & sin_latitude, longitude_rad, land_frac, pressure_fl, temperature_fl, &
  & zrgp, thermodynamics_out, iseed)

  use radiation_single_level,   only : single_level_type
  use radiation_thermodynamics, only : thermodynamics_type
  use radiation_gas,            only : gas_type, IMassMixingRatio, &
        &   IH2O, ICO2, IO3, IN2O, ICH4, ICFC11, ICFC12, IHCFC22, ICCL4
  use radiation_cloud,          only : cloud_type
  use radiation_aerosol,        only : aerosol_type
  use radiation_setup,          only : tradiation

  implicit none

  class(RADINTG_ZRGP_TYPE), intent(in)    :: zrgp_fields

  ! Configuration for the radiation scheme, IFS style
  type(tradiation), intent(in)          :: yradiation

  integer, intent(in) :: ncol, nlev, nproma  ! Number of columns and levels

  ! Derived types for the inputs to the radiation scheme
  type(single_level_type), intent(in)   :: single_level
  type(thermodynamics_type), intent(in) :: thermodynamics
  type(gas_type), intent(in)            :: gas
  type(cloud_type), intent(in)          :: cloud
  type(aerosol_type), intent(in)        :: aerosol

  ! Additional input data, required for effective radii calculation
  real(jprb), dimension(:), intent(in)   :: sin_latitude, longitude_rad, land_frac
  real(jprb), dimension(:,:), intent(in) :: pressure_fl, temperature_fl

  ! monolithic IFS data structure to pass to radiation scheme
  real(kind=jprb), intent(out), allocatable :: zrgp(:,:,:)

  ! Empty thermodynamics type to store pressure_hl for output at the end
  type(thermodynamics_type), intent(inout), optional  :: thermodynamics_out

  ! Seed for random number generator
  integer, intent(out), allocatable, optional :: iseed(:,:)

  ! number of column blocks, block size
  integer :: ngpblks

  integer :: jrl, ibeg, iend, il, ib, ifld, jemiss, jalb, jlev, joff, jaer

  ! Extract some config values
  ngpblks=(ncol-1)/nproma+1              ! number of column blocks

  ! Allocate blocked data structure
  allocate(zrgp(nproma,zrgp_fields%ifldstot,ngpblks))
  if(present(thermodynamics_out)) allocate(thermodynamics_out%pressure_hl(ncol,nlev+1))
  if(present(iseed)) allocate(iseed(nproma,ngpblks))

  ! First touch
  !$OMP PARALLEL DO SCHEDULE(RUNTIME)&
  !$OMP&PRIVATE(IB,IFLD)
  do ib=1,ngpblks
    do ifld=1,zrgp_fields%ifldstot
      zrgp(:,ifld,ib) = 0._jprb
    enddo
    if(present(iseed)) iseed(:,ib) = 0
  enddo
  !$OMP END PARALLEL DO

  associate(yderad=>yradiation%yrerad, rad_config=>yradiation%rad_config)

    ! REPLACED ich4 with iich4 due to clash
    ! REPLACED in2o with iin2o due to clash
    ! REPLACED ico2 with iico2 due to clash

    !  -------------------------------------------------------
    !
    !  INPUT LOOP
    !
    !  -------------------------------------------------------

    !$OMP PARALLEL DO SCHEDULE(RUNTIME)&
    !$OMP&PRIVATE(JRL,IBEG,IEND,IL,IB,JAER,JOFF,JLEV,JALB)
    do jrl=1,ncol,nproma

      ibeg=jrl
      iend=min(ibeg+nproma-1,ncol)
      il=iend-ibeg+1
      ib=(jrl-1)/nproma+1

      !* RADINTG:  3.      PREPARE INPUT ARRAYS

      ! zrgp(1:il,imu0,ib)  = ???
      zrgp(1:il,zrgp_fields%iamu0,ib)  =  single_level%cos_sza(ibeg:iend)   ! cosine of solar zenith ang (mu0)

      do jemiss=1,yderad%nlwemiss
        zrgp(1:il,zrgp_fields%iemiss+jemiss-1,ib)  =  single_level%lw_emissivity(ibeg:iend,jemiss)
      enddo

      zrgp(1:il,zrgp_fields%its,ib)      = single_level%skin_temperature(ibeg:iend)  ! skin temperature
      zrgp(1:il,zrgp_fields%islm,ib)     = land_frac(ibeg:iend) ! land-sea mask
      zrgp(1:il,zrgp_fields%iccnl,ib)    = yderad%rccnlnd ! CCN over land
      zrgp(1:il,zrgp_fields%iccno,ib)    = yderad%rccnsea ! CCN over sea
      ! zrgp(1:il,ibas,ib)     = ???
      ! zrgp(1:il,itop,ib)     = ???
      zrgp(1:il,zrgp_fields%igelam,ib)   = longitude_rad(ibeg:iend) ! longitude
      zrgp(1:il,zrgp_fields%igemu,ib)    = sin_latitude(ibeg:iend) ! sine of latitude
      ! zrgp(1:il,iclon,ib)    = ???
      ! zrgp(1:il,islon,ib)    = ???

      do jalb=1,yderad%nsw
        zrgp(1:il,zrgp_fields%iald+jalb-1,ib)  =  single_level%sw_albedo(ibeg:iend,jalb)
      enddo

      if (allocated(single_level%sw_albedo_direct)) then
        do jalb=1,yderad%nsw
          zrgp(1:il,zrgp_fields%ialp+jalb-1,ib)  =  single_level%sw_albedo_direct(ibeg:iend,jalb)
        end do
      else
        do jalb=1,yderad%nsw
          zrgp(1:il,zrgp_fields%ialp+jalb-1,ib)  =  single_level%sw_albedo(ibeg:iend,jalb)
        end do
      end if

      do jlev=1,nlev
        zrgp(1:il,zrgp_fields%iti+jlev-1,ib)   = temperature_fl(ibeg:iend,jlev) ! full level temperature
        zrgp(1:il,zrgp_fields%ipr+jlev-1,ib)   = pressure_fl(ibeg:iend,jlev) ! full level pressure
        ! zrgp(1:il,iqs+jlev-1,ib)   = ???
      enddo

      do jlev=1,nlev
        zrgp(1:il,zrgp_fields%iwv+jlev-1,ib)   = gas%mixing_ratio(ibeg:iend,jlev,IH2O) ! this is already in MassMixingRatio units
        if (rad_config%do_clouds) then
          zrgp(1:il,zrgp_fields%iclc+jlev-1,ib)  = cloud%fraction(ibeg:iend,jlev)
          zrgp(1:il,zrgp_fields%ilwa+jlev-1,ib)  = cloud%q_liq(ibeg:iend,jlev)
          zrgp(1:il,zrgp_fields%iiwa+jlev-1,ib)  = cloud%q_ice(ibeg:iend,jlev)
        else
          zrgp(1:il,zrgp_fields%iclc+jlev-1,ib)  = 0._jprb
          zrgp(1:il,zrgp_fields%ilwa+jlev-1,ib)  = 0._jprb
          zrgp(1:il,zrgp_fields%iiwa+jlev-1,ib)  = 0._jprb
        endif
        zrgp(1:il,zrgp_fields%iswa+jlev-1,ib)  = 0._jprb  ! snow
        zrgp(1:il,zrgp_fields%irwa+jlev-1,ib)  = 0._jprb  ! rain

        ! zrgp(1:il,irra+jlev-1,ib)  = ???
        ! zrgp(1:il,idp+jlev-1,ib)   = ???
        ! zrgp(1:il,ifsd+jlev-1,ib)   = ???
        ! zrgp(1:il,iecpo3+jlev-1,ib) = ???
      enddo

      zrgp(1:il,zrgp_fields%iaer:zrgp_fields%iaer+nlev,ib)  =  0._jprb ! old aerosol, not used
      if (yderad%naermacc == 1) then
        joff=zrgp_fields%iaero
        do jaer=1,rad_config%n_aerosol_types
          do jlev=1,nlev
            zrgp(1:il,joff,ib) = aerosol%mixing_ratio(ibeg:iend,jlev,jaer)
            joff=joff+1
          enddo
        enddo
      endif

      do jlev=1,nlev+1
        ! zrgp(1:il,ihpr+jlev-1,ib)  = ???
        zrgp(1:il,zrgp_fields%iaprs+jlev-1,ib) = thermodynamics%pressure_hl(ibeg:iend,jlev)
        zrgp(1:il,zrgp_fields%ihti+jlev-1,ib)  = thermodynamics%temperature_hl(ibeg:iend,jlev)
      enddo

      ! -- by default, globally averaged concentrations (mmr)
      call gas%get(ICO2, IMassMixingRatio, zrgp(1:il,zrgp_fields%iico2:zrgp_fields%iico2+nlev-1,ib), istartcol=ibeg)
      call gas%get(ICH4, IMassMixingRatio, zrgp(1:il,zrgp_fields%iich4:zrgp_fields%iich4+nlev-1,ib), istartcol=ibeg)
      call gas%get(IN2O, IMassMixingRatio, zrgp(1:il,zrgp_fields%iin2o:zrgp_fields%iin2o+nlev-1,ib), istartcol=ibeg)
      call gas%get(ICFC11, IMassMixingRatio, zrgp(1:il,zrgp_fields%ic11:zrgp_fields%ic11+nlev-1,ib), istartcol=ibeg)
      call gas%get(ICFC12, IMassMixingRatio, zrgp(1:il,zrgp_fields%ic12:zrgp_fields%ic12+nlev-1,ib), istartcol=ibeg)
      call gas%get(IHCFC22,IMassMixingRatio, zrgp(1:il,zrgp_fields%ic22:zrgp_fields%ic22+nlev-1,ib), istartcol=ibeg)
      call gas%get(ICCL4,  IMassMixingRatio, zrgp(1:il,zrgp_fields%icl4:zrgp_fields%icl4+nlev-1,ib), istartcol=ibeg)
      call gas%get(IO3, IMassMixingRatio, zrgp(1:il,zrgp_fields%ioz:zrgp_fields%ioz+nlev-1,ib), istartcol=ibeg)
      ! convert ozone kg/kg to Pa*kg/kg
      ! do jlev=1,nlev
      !   zrgp(1:il,zrgp_fields%ioz+jlev-1,ib)  = zrgp(1:il,zrgp_fields%ioz+jlev-1,ib) &
      !         &                       * (thermodynamics%pressure_hl(ibeg:iend,jlev+1) &
      !         &                         - thermodynamics%pressure_hl(ibeg:iend,jlev))
      ! enddo

      ! local workaround variables for standalone input files
#ifdef BITIDENTITY_TESTING
      ! To validate results against standalone ecrad, we overwrite effective
      ! radii, cloud overlap and seed with input values
      if (rad_config%do_clouds) then
        do jlev=1,nlev
          ! missing full-level temperature and pressure as well as land-sea-mask
          zrgp(1:il,zrgp_fields%ire_liq+jlev-1,ib) = cloud%re_liq(ibeg:iend,jlev)
          zrgp(1:il,zrgp_fields%ire_ice+jlev-1,ib) = cloud%re_ice(ibeg:iend,jlev)
        enddo
        do jlev=1,nlev-1
          ! for the love of it, I can't figure this one out. Probably to do with
          ! my crude approach of setting PGEMU?
          zrgp(1:il,zrgp_fields%ioverlap+jlev-1,ib) = cloud%overlap_param(ibeg:iend,jlev)
        enddo
        if(present(iseed)) iseed(1:il,ib) = single_level%iseed(ibeg:iend)
      else
        do jlev=1,nlev
          ! missing full-level temperature and pressure as well as land-sea-mask
          zrgp(1:il,zrgp_fields%ire_liq+jlev-1,ib) = 0._jprb
          zrgp(1:il,zrgp_fields%ire_ice+jlev-1,ib) = 0._jprb
        enddo
        do jlev=1,nlev-1
          zrgp(1:il,zrgp_fields%ioverlap+jlev-1,ib) = 0._jprb
        enddo
        if(present(iseed)) iseed(1:il,ib) = 0
      endif ! do_clouds
#endif
    enddo
    !$OMP END PARALLEL DO

    ! Store pressure for output
    if(present(thermodynamics_out)) thermodynamics_out%pressure_hl(:,:) = thermodynamics%pressure_hl(:,:)

  end associate

end subroutine ifs_copy_inputs_to_blocked

subroutine ifs_copy_fluxes_from_blocked(&
    & zrgp_fields, yradiation, ncol, nlev, nproma, &
    & zrgp, flux, flux_sw_direct_normal, flux_uv, flux_par, flux_par_clear,&
    & emissivity_out, flux_diffuse_band, flux_direct_band)
  use radiation_setup,          only : tradiation
  use radiation_flux,           only : flux_type

  class(radintg_zrgp_type), intent(in)     :: zrgp_fields

  ! Configuration for the radiation scheme, IFS style
  type(tradiation), intent(in)          :: yradiation

  integer, intent(in) :: ncol, nlev, nproma  ! Number of columns and levels

  ! monolithic IFS data structure passed to radiation scheme
  real(kind=jprb), intent(inout), allocatable :: zrgp(:,:,:)

  ! Derived type containing outputs from the radiation scheme
  type(flux_type), intent(inout)              :: flux

  ! Additional output fluxes as arrays
  real(jprb), dimension(:), intent(inout)     :: flux_sw_direct_normal, flux_uv, flux_par,&
                                                 & flux_par_clear, emissivity_out
  real(jprb), dimension(:,:), intent(inout) :: flux_diffuse_band, flux_direct_band

  ! number of column blocks, block size
  integer :: ngpblks

  integer :: jrl, ibeg, iend, il, ib, jlev, jg

  ! Extract some config values
  ngpblks=(ncol-1)/nproma+1              ! number of column blocks

    !  -------------------------------------------------------
    !
    !  OUTPUT LOOP
    !
    !  -------------------------------------------------------

    !$OMP PARALLEL DO SCHEDULE(RUNTIME)&
    !$OMP&PRIVATE(JRL,IBEG,IEND,IL,IB,JLEV,JG)
    do jrl=1,ncol,nproma
      ibeg=jrl
      iend=min(ibeg+nproma-1,ncol)
      il=iend-ibeg+1
      ib=(jrl-1)/nproma+1

      do jlev=1,nlev+1
        flux%sw_up(ibeg:iend,jlev) = zrgp(1:il,zrgp_fields%ifrso+jlev-1,ib)
        flux%lw_up(ibeg:iend,jlev) = zrgp(1:il,zrgp_fields%ifrth+jlev-1,ib)
        flux%sw_up_clear(ibeg:iend,jlev) = zrgp(1:il,zrgp_fields%iswfc+jlev-1,ib)
        flux%lw_up_clear(ibeg:iend,jlev) = zrgp(1:il,zrgp_fields%ilwfc+jlev-1,ib)
        if (yradiation%yrerad%lapproxlwupdate) then
          flux%lw_derivatives(ibeg:iend,jlev) = zrgp(1:il,zrgp_fields%ilwderivative+jlev-1,ib)
        else
          flux%lw_derivatives(ibeg:iend,jlev) = 0.0_jprb
        endif
      end do
      flux%sw_dn(ibeg:iend,nlev+1) = zrgp(1:il,zrgp_fields%ifrsod,ib)
      flux%lw_dn(ibeg:iend,nlev+1) = zrgp(1:il,zrgp_fields%ifrted,ib)
      flux%sw_dn_clear(ibeg:iend,nlev+1) = zrgp(1:il,zrgp_fields%ifrsodc,ib)
      flux%lw_dn_clear(ibeg:iend,nlev+1) = zrgp(1:il,zrgp_fields%ifrtedc,ib)
      flux%sw_dn_direct(ibeg:iend,nlev+1) = zrgp(1:il,zrgp_fields%ifdir,ib)
      flux%sw_dn_direct_clear(ibeg:iend,nlev+1) = zrgp(1:il,zrgp_fields%icdir,ib)
      flux_sw_direct_normal(ibeg:iend) = zrgp(1:il,zrgp_fields%isudu,ib)
      flux_uv(ibeg:iend) = zrgp(1:il,zrgp_fields%iuvdf,ib)
      flux_par(ibeg:iend) = zrgp(1:il,zrgp_fields%iparf,ib)
      flux_par_clear(ibeg:iend) = zrgp(1:il,zrgp_fields%iparcf,ib)
      flux%sw_dn(ibeg:iend,1) = zrgp(1:il,zrgp_fields%itincf,ib)
      emissivity_out(ibeg:iend) = zrgp(1:il,zrgp_fields%iemit,ib)
      if (yradiation%yrerad%lapproxswupdate) then
        do jg=1,yradiation%yrerad%nsw
          flux_diffuse_band(ibeg:iend,jg) = zrgp(1:il,zrgp_fields%iswdiffuseband+jg-1,ib)
          flux_direct_band(ibeg:iend,jg) = zrgp(1:il,zrgp_fields%iswdirectband+jg-1,ib)
        end do
      else
        flux_diffuse_band(ibeg:iend,:) = 0.0_jprb
        flux_direct_band(ibeg:iend,:) = 0.0_jprb
      endif
    end do

    deallocate(zrgp)

end subroutine ifs_copy_fluxes_from_blocked

END MODULE RADINTG_ZRGP_MOD
